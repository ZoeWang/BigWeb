<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>http 相关</title>
</head>
<body>
	<p>http 跨域原理 2次请求，第一次 options 返回是否有权限跨域，第二次请求数据</p>

	http://www.cnblogs.com/Peng2014/p/4686327.html


查浏览器缓存
不存在， 操作系统做DNS查询，返回IP地址给浏览器
浏览器打开对服务器的TCP连接，完成3次握手
浏览器通过TCP连接发送HTTP请求
浏览器接收HTTP响应并且可能关掉TCP连接，或者是重新使用连接处理新请求
浏览器检查HTTP响应是否为一个重定向（3xx 结果状态码 ），一个验证请求（401），错误（4xx 5xx）等等，这些都是不同响应的正常处理（2xx）.
如果响应可缓存，将存入缓存
9.浏览器解码响应（例如：如果它是gzziped压缩）。

10.浏览器决定如何处理这些响应（例如，它是HTML页面，一张图片，一段音乐）。

11.浏览器展现响应，对未知类型还会弹出下载对话框。


	Piskvor的回答：
    作一个简单粗暴的描述，假设是简单的HTTP请求，IPV4，没有代理。
1.浏览器查询缓存，如果缓存存在跳到第9步。

2.浏览器询问操作系统服务器的IP地址。

3.操作系统做DNS查询，返回IP地址给浏览器。

4.浏览器打开对服务器的TCP连接（如果是HTTPS协议的话会更复杂）。

5.浏览器通过TCP连接发送HTTP请求。

6.浏览器接收HTTP响应并且可能关掉TCP连接，或者是重新使用连接处理新请求。

7.浏览器检查HTTP响应是否为一个重定向（3xx 结果状态码 ），一个验证请求（401），错误（4xx 5xx）等等，这些都是不同响应的正常处理（2xx）.

8.如果响应可缓存，将存入缓存。

9.浏览器解码响应（例如：如果它是gzziped压缩）。

10.浏览器决定如何处理这些响应（例如，它是HTML页面，一张图片，一段音乐）。

11.浏览器展现响应，对未知类型还会弹出下载对话框。

这里边的每个步骤都可以长篇大论一番，当然还有很多东西与这些步骤平行发生。




详细版

    1、浏览器会开启一个线程来处理这个请求，对URL 分析判断如果是 http 协议就按照 Web 方式来处理;

    2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;

    3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;

    4、进行HTTP协议会话，客户端发送报头(请求报头);

    5、进入到web服务器上的 WebServer，如 Apache、Tomcat、Node.js 等服务器;

    6、进入部署好的后端应用，如PHP、Java、JavaScript、Python 等，找到对应的请求处理;

    7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;

    8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;

    9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;

    10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。

 

    简洁版：

    浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；

    服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；

    浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；

    载入解析到的资源文件，渲染页面，完成。

 

    其它：

    1：当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。

    2： 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

    3：一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。

    4：此时，Web服务器提供资源服务，客户端开始下载资源。请求返回后，便进入了我们关注的前端模块。简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSSRule Tree，而javascript又可以根据DOMAPI操作DOM



在浏览器里输入网址或者点击链接，网页打开了……这是我们上网时再普通不过的一幕，但是如此简单的表象背后，却隐藏着无比复杂的技术流程。想涨涨知识吗？往下看吧。
一个HTTP请求的过程
为了简化我们先从一个HTTP请求开始，简要介绍一下一个HTTP求情的网络传输过程，也就是所谓的“从输入URL到页面下载完的过程中都发生了什么事情”。
● DNS Lookup 先获得URL对应的IP地址
● Socket Connect 浏览器和服务器建立TCP连接
● Send Request 发送HTTP请求
● Content Download 服务器发送响应
如果下到物理层去讲就有点耍流氓了。如果这些你还认可这几个步骤的话，我们就来讲一下这里面存在的性能问题。
● 如果你对DNS的查询还有印象的话现在反思一下，DNS Lookup就是为了获取一串IP地址要和无数个DNS服务器进行通信，这要消耗多少时间？别忘了，你查询完了的时候，你还没和那边的服务器通信呢。
● TCP连接要三次握手。如果服务器很远的话这三次握手要花多少时间？别忘了建立连接之后你还没发请求呢。（通常到这里0.5秒就出去了）
● 发送HTTP请求的时候你要知道一点，就是我们的网络带宽上行和下行通常是不一样的，通常上行的带宽会小一些，一个的话还好，但是现在的网页通常都会后续请求很多资源，带宽小的时候上行拥塞怎么办？别忘了已经到第三步了，服务器还没给你发响应呢，现在你的浏览器还什么都画不出来。
● 终于到了服务器发响应了，不巧你访问的这个服务器比较忙，好几万个人都要这个资源，服务器的上行带宽也是有限的，怎么办？
我觉得我出了几道还不错的面试题。顺便提一下，前两步的延迟和网络带宽的影响不大；后两步加带宽是能一定程度缓解，不过你要有钱，而且很贵。
虽说博主做过WebKit本地渲染的优化，但是深知网页加载的主要时间还是浪费在网络通信上，所以在这些步骤上的优化会比你在浏览器内核的优化省力且效果明显。
网络方面的主要优化手段，总结一下不外乎缓存、预取、压缩、并行。以后如果再有面试问性能优化之类的问题，大家都可以照着这个思路去考虑。
下面就分阶段介绍一下现有的优化手段。
DNS优化
对于DNS优化，缓存无疑是最简单粗暴且效果明显的了。说到缓存就一定要提到缓存层级：
● 浏览器DNS缓存
● 系统DNS缓存
● Hosts文件
● 各个DNS服务器上的缓存
当然DNS缓存失效期通常都比较短，很多情况下都要再去查找。为了降低用户体验到的延迟（注意这里不是网络延时），预取是一个不错的方法。
比如说你敲网址的时候还没有敲完，但是浏览器根据你的历史发现你很有可能去访问哪个网站，就提前给你做DNS预取了，比如你打了一个“w”的时候，chrome已经帮你去找weibo.com的IP地址了。chrome用户看一下chrome://predictors 你就知道了。
此外浏览器还会记录你过去的历史，知道每个域名下通常还会有哪些其他的链接，以便建立起网站的拓扑结构。当你访问这个域名下的网站，它就会预先对其他链接的域名进行DNS解析。
TCP优化
看到前面的DNS的具体优化这么繁杂，知道这简单的一步没那么简单了吧。
结果到TCP这一步优化反而简单了，因为刚才DNS已经把IP都预先弄到了，那么我们顺着刚才的步骤再建立连接就好了。
所以在你敲第一个字母的时候，DNS解析完了就去建立连接了，这时候你可能网址还没敲完。当你刚访问一个网站的时候，浏览器刷刷刷的帮你把到别的服务器的TCP连接给你建好。
HTTP传输优化
写到这里可能有人会想，既然已经把TCP连接建立好了，那我干脆预取更进一步，把所有的链接内容直接预取下来不就好了，这样我网址还没敲完网页就已经加载完成了。
这个想法是好的，但现实却是残酷的，因为要记住我们的带宽是有限的，DNS和TCP连接量级都比较轻，对网络带宽不会占据太多，但是HTTP传输就不一样了。如果你所有链接都去预取的话，你的带宽很快就被占满了，这样你正常的请求无法得到满足，性能反而会严重下降。
缓存就又出现了，提缓存必提层次结构。
● PageCache 这个是最快的了，直接在内存中缓存了现有网页的DOM结构和渲染结果，这就是你为什么在点前进后退的时候会这么快。
● HTTP Cache 文件级别的Cache存在本地的文件系统上按照RFC2616实现。
● 代理Cache 如果是通过代理服务器上网的话，代理服务器通常也会按照缓存标准
● CDN 一个地理上离你很近的内容服务器，比如说你在北京请求杭州淘宝的一个图片，结果在北京的一个CDN上有这个图片，那么就不用去杭州了。
● DMOC（distributed memory object caching system）CDN主要存放的是静态数据，但是网页中通常有很多动态的数据需要查数据库，流量多了压力就会很大，通常服务器外围还会有一层内存缓存服务器，专门缓存这些数据库中的对象，据《淘宝技术这10年》称可以减少99.5%的数据库访问。
● Server 其实真正落在服务器上的请求已经不多了。
大家看到这里有没有想到能在什么地方再加一层缓存呢？其实可以在2和3之间加，也就是在路由器上加缓存。
小米路由器和搜狗合作的预取引擎其实就相当于在路由器上加一层缓存款顺便智能预取一下。为什么在这里另起一段专门谈小米呢？难不成是小米的水军？才不是呢，是因为博主看到这个消息的时候心都凉了，和博主的毕设撞车了有木有。
去年在360刚出随身Wi-Fi的时候博主想到了这么个点子，还想着把这个东西做出来之后用这个创业和360谈合作，结果最近刚做完，论文也投出去了，幻想着开启人生巅峰，颠覆行业，结果就发现小米和搜狗出了这么个一样的东西还都商业化了。说好的人生巅峰就这样没有了，早知道去年就先申请个专利了。
另一个HTTP常用的优化就是压缩了，网络传输时间＝消息大小/网速。既然网速比较贵那么就压缩一下吧，大部分服务器都会对HTTP消息进行gzip压缩。可以在Http Header中看到，具体的就不细说了。
未来协议：SPDY
上面的都是传统做法，下面讲一个未来的技术。由于HTTP协议是上个世纪制定的协议了，已经不能很好地适应现在Web的发展，所以Google提出了SPDY协议，目前是指定中的HTTP2.0标准的一个底版。
SPDY主要有下面的特点：
● 一个TCP连接上并行多个HTTP连接，减少连接的建立时间。
● 请求优先级（目前还没看到具体实现）。
● HTTP头部压缩，上文提到的HTTP压缩是对HTTP body的压缩，并没有对头部压缩。对于小的HTTP消息，头部的比重还是很大的，而现在的web中存在大量小消息。
● Server push/hint 服务器主动推送对象（可以想象成服务器帮客户端预取）。
业界目前对SPDY是有赞有弹，博主也持谨慎的态度，主要在1和4上，4其实和之前提到的HTTP直接预取的矛盾点一样，万一推送的不需要又占据了带宽怎么办？hint到底该如何实现都有困难。
第一条潜在的风险就是TCP连接中途断开，那么所有的连接就全部停掉了，PC互联网这种情况可能会少一些，但是移动互联网中TCP连接断开的情况还是比较常见的。







HTTP（HyperText Transport Protocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。
通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个指示头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。

</body>
</html>